error.list <- list()
## reading the Basswood data
raw.files <- list.files('./tests-data/',
pattern = '[^all]\\.shp',
recursive = TRUE,
full.names = TRUE)
error.list <- list()
for (i in 1:length(raw.files)){
raw.yield <- st_read(raw.files[i])
yldmp <- try(pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
cores = 15,
verbose = TRUE), silent = TRUE)
field.name <- basename(raw.files[i])
field.name <- gsub('\\.shp', '', field.name)
if(!inherits(yldmp, 'try-error')){
png(file.path('./tests-results/basswood-ritas/', paste0(field.name, '.png')),
width = 6 * 300, height = 5 * 300, res = 300)
plot(yldmp['yield'], border = 'transparent')
dev.off()
}else{
res <- list(file = raw.files[i],
error = yldmp)
error.list <- append(error.list, res)
}
}
raw.files[i]
## reading the Basswood data
raw.files <- list.files('./tests-data/',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
raw.files
## reading the Basswood data
raw.files <- list.files('./tests-data/',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
error.list <- list()
for (i in 1:length(raw.files)){
raw.yield <- st_read(raw.files[i])
yldmp <- try(pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
cores = 15,
verbose = TRUE), silent = TRUE)
field.name <- basename(raw.files[i])
field.name <- gsub('\\.shp', '', field.name)
if(!inherits(yldmp, 'try-error')){
png(file.path('./tests-results/basswood-ritas/', paste0(field.name, '.png')),
width = 6 * 300, height = 5 * 300, res = 300)
plot(yldmp['yield'], border = 'transparent')
dev.off()
}else{
res <- list(file = raw.files[i],
error = yldmp)
error.list <- append(error.list, res)
}
}
devtools::load_all()
require(pacu)
require(terra)
require(sf)
require(gstat)
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
## selecting the 2012 dataset to test
i <- 16
raw.yield <- st_read(raw.files[i])
## converting flow to kg/s and width and distance to meters... let's see
## if our approach is robust
raw.yield2 <- raw.yield
raw.yield2$FLOW <- raw.yield2$FLOW * 0.454
raw.yield$SWATH <- raw.yield2$SWATH * 0.0254
raw.yield$DISTANCE <- raw.yield2$DISTANCE * 0.0254
raw.yield$DISTANCE
raw.yield$DISTANCE |> summary()
raw.yield$DISTANCE |> summary()
raw.yield2$DISTANCE |> summary()
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
## selecting the 2012 dataset to test
i <- 16
raw.yield <- st_read(raw.files[i])
## converting flow to kg/s and width and distance to meters... let's see
## if our approach is robust
raw.yield2 <- raw.yield
raw.yield2$FLOW <- raw.yield2$FLOW * 0.454
raw.yield2$SWATH <- raw.yield2$SWATH * 0.0254
raw.yield2$DISTANCE <- raw.yield2$DISTANCE * 0.0254
pacu:::.pa_get_variable(raw.yield2, 'width', 'm', 'SWATH', TRUE)
pacu:::.pa_get_variable(raw.yield2, 'width', 'm', 'SWATH', TRUE) |> summary()
pacu:::.pa_get_variable(raw.yield2, 'width', 'cm', 'SWATH', TRUE) |> summary()
pacu:::.pa_get_variable(raw.yield2, 'width', 'in', 'SWATH', TRUE) |> summary()
pacu:::.pa_get_variable(raw.yield2, 'width', 'in', 'SWATH', TRUE) |> head()
pacu:::.pa_get_variable(raw.yield2, 'width', 'm', 'SWATH', TRUE) |> head()
pacu:::.pa_get_variable(raw.yield2, 'width', 'cm', 'SWATH', TRUE) |> head()
require(pacu)
require(terra)
require(sf)
require(gstat)
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
## selecting the 2012 dataset to test
i <- 16
cores <- 10
raw.yield <- st_read(raw.files[i])
unsp.units <- pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
cores = cores,
verbose = TRUE)
plot(unsp.units['yield'], border = 'transparent')
sp.units <- pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
data.units = c('lb/s', '%', 's', 'degreeN', 'in', 'in'),
cores = cores,
verbose = TRUE)
plot(sp.units['yield'], border = 'transparent')
## converting flow to kg/s and width and distance to meters... let's see
## if our approach is robust
raw.yield2 <- raw.yield
raw.yield2$FLOW <- raw.yield2$FLOW * 0.454
raw.yield2$SWATH <- raw.yield2$SWATH * 0.0254
raw.yield2$DISTANCE <- raw.yield2$DISTANCE * 0.0254
sp.units2 <- pa_yield_map(raw.yield = raw.yield2,
algorithm = 'ritas',
data.units = c('kg/s', '%', 's', 'degreeN', 'm', 'm'),
cores = cores,
verbose = TRUE)
unsp.units$yield == sp.units$yield
all(unsp.units$yield == sp.units$yield)
all(unsp.units$yield == sp.units$yield == sp.units2$yield)
all(unsp.units$yield == sp.units$yield &
unsp.units$yield  == sp.units2$yield)
unsp.units$yield  == sp.units2$yield
plot(sp.units['yield'], border = 'transparent')
plot(sp.units2['yield'], border = 'transparent')
plot(unsp.units['yield'], border = 'transparent')
st_area(sp.units)
st_area(sp.units) |> mean()
st_area(sp.units2) |> mean()
plot(unsp.units['yield'], border = 'transparent')
=
plot(sp.units['yield'], border = 'transparent')
plot(sp.units2['yield'], border = 'transparent')
unsp.units
unsp.units$yield / 0.85
unsp.units$yield15m <- unsp.units$yield / 0.85
plot(unsp.units['yield15m'], border = 'transparent')
plot(raw.yield['Yld_Vol_Dr'])
names(raw.yield)
plot(raw.yield['DRY_BU_AC'])
raw.yield$DRY_G_M2 <- raw.yield$DRY_BU_AC * 56 * 454 / 4046
plot(raw.yield['DRY_G_M2'])
## Checking the agreement between the observed raw data and the kriged
raw.yield$DRY_G_M2 <- raw.yield$DRY_BU_AC * 56 * 454 / 4046
aggregate(unsp.units['yield'],
raw.yield,
mean)
raw.yield
st_crs(raw.yield) <- 'espg:4326'
raw.yield <- pa_2utm(raw.yield)
st_crs(raw.yield) <- 'espg:4326'
raw.yield <- pa_2utm(raw.yield)
raw.yield <- pa_2utm(raw.yield, TRUE)
raw.yield
st_crs(raw.yield) <- 'espg:4326'
raw.yield
sf::st_crs(raw.yield) <- 'epsg:4326'
raw.yield <- pa_2utm(raw.yield, TRUE)
aggregate(unsp.units['yield'],
raw.yield,
mean)
comp <- aggregate(unsp.units['yield'],
raw.yield,
mean)
comp <- st_join(comp, raw.yield['DRY_G_M2'], left = TRUE, join = st_equals())
comp <- st_join(comp, raw.yield['DRY_G_M2'], left = TRUE, join = st_equals)
plot(comp$DRY_G_M2, comp$yield)
abline(0, 1, 'red')
abline(0, 1, col = 'red')
plot(comp$DRY_G_M2, comp$yield, xlab = 'Combine recorded yield (g/m2)',
ylab = 'Ritas estimated yield (g/m2')
abline(0, 1, col = 'red')
plot(comp$DRY_G_M2, comp$yield, xlab = 'Combine recorded yield (g/m2)',
ylab = 'Ritas estimated yield (g/m2', xlim = c(0, 2500), ylab = c(0, 2500))
plot(comp$DRY_G_M2, comp$yield, xlab = 'Combine recorded yield (g/m2)',
ylab = 'Ritas estimated yield (g/m2', xlim = c(0, 2500), ylim = c(0, 2500))
abline(0, 1, col = 'red')
plot(comp['yield'])
plot(comp)
plot(comp$DRY_G_M2, comp$yield, xlab = 'Combine recorded yield (g/m2)',
ylab = 'Ritas estimated yield (g/m2', xlim = c(0, 2500), ylim = c(0, 2500))
abline(0, 1, col = 'red')
devtools::load_all()
devtools::build()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::load_all()
require(terra)
require(sf)
require(gstat)
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
error.list <- list()
for (i in 1:length(raw.files)){
raw.yield <- st_read(raw.files[i])
yldmp <- try(pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
cores = 10,
verbose = TRUE), silent = TRUE)
field.name <- basename(raw.files[i])
field.name <- gsub('\\.shp', '', field.name)
if(!inherits(yldmp, 'try-error')){
png(file.path('./tests-results/basswood-ritas/', paste0(field.name, '.png')),
width = 6 * 300, height = 5 * 300, res = 300)
plot(yldmp['yield'], border = 'transparent')
dev.off()
}else{
res <- list(file = raw.files[i],
error = yldmp)
error.list <- append(error.list, res)
}
}
warnings()
yldmp
raw.yield
i
raw.files
raw.files
error.list
error.list <- list()
for (i in 13:length(raw.files)){
raw.yield <- st_read(raw.files[i])
yldmp <- try(pa_yield_map(raw.yield = raw.yield,
algorithm = 'ritas',
cores = 10,
verbose = TRUE), silent = TRUE)
field.name <- basename(raw.files[i])
field.name <- gsub('\\.shp', '', field.name)
if(!inherits(yldmp, 'try-error')){
png(file.path('./tests-results/basswood-ritas/', paste0(field.name, '.png')),
width = 6 * 300, height = 5 * 300, res = 300)
plot(yldmp['yield'], border = 'transparent')
dev.off()
}else{
res <- list(file = raw.files[i],
error = yldmp)
error.list <- append(error.list, res)
}
}
error.list
raw.files
is.null(c('haha', 'hehe', NULL))
bb <- c('haha', 'hehe', NULL)
bb
bb <- list('haha', 'hehe', NULL)
bb
is.null(bb)
sapply(bb, is.null)
devtools::load_all()
## reading the Basswood data
raw.files <- list.files('./tests-data/basswood',
pattern = '[^all]\\.shp$',
recursive = TRUE,
full.names = TRUE)
## selecting the 2012 dataset to test
i <- 16
cores <- 1
raw.yield <- st_read(raw.files[i])
require(terra)
require(sf)
require(gstat)
raw.yield <- st_read(raw.files[i])
raw.yield |> names()
raw.yield[-7]
raw.yield[-7] |> names()
raw.yield |> names()
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7],
algorithm = 'ritas',
cores = cores,
verbose = TRUE)
devtools::load_all()
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7],
algorithm = 'ritas',
cores = cores,
verbose = TRUE)
raw.yield |> names()
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7:-8],
algorithm = 'ritas',
cores = cores,
verbose = TRUE)
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7:-8],
algorithm = 'ritas',
cores = cores,
verbose = FALSE)
devtools::load_all()
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7:-8],
algorithm = 'ritas',
cores = cores,
verbose = FALSE)
unsp.units <- pa_yield_map(raw.yield = raw.yield[-7:-8],
algorithm = 'ritas',
cores = cores,
verbose = TRUE)
require(terra)
require(sf)
require(gstat)
raw.yield <- st_read('./inst/extdata/to-delete/raw-yield.shp')
app.n <- st_read('./inst/extdata/to-delete/as-applied-n.shp')
app.s <- st_read('./inst/extdata/to-delete/as-applied-s.shp')
app.n |> names()
app.n |> head()
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
interval <- app.n[['Duration_s']]
pa_flow2mass(flow, interval, moisture)
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
moisture <- 0
interval <- app.n[['Duration_s']]
pa_flow2mass(flow, interval, moisture)
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
app.n[['Rate_Mass']]
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate_Mass']]
flow
app.n
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate__Mass']]
moisture <- 0
interval <- app.n[['Duration_s']]
pa_flow2mass(flow, interval, moisture)
plot(density(app.n$Rate__Mass))
units(flow) <- units::as_units('lb/s')
units(interval) <- units::as_units('s')
pa_flow2mass(flow, interval, moisture)
## testing how to aggregate the nitrogen and seed information
flow <- app.n[['Rate__Mass']]
units(flow) <- units::as_units('lb/s')
moisture <- 0
units(moisture) <- units::as_units('%')
interval <- app.n[['Duration_s']]
units(interval) <- units::as_units('s')
pa_flow2mass(flow, interval, moisture)
f.mass <- pa_flow2mass(flow, interval, moisture)
f.mass |> density() |> plot()
raw.yield
app.n
swath <- app.n['Swth_Wdth_']
units(swath) <- units::as_units('ft')
swath <- app.n[['Swth_Wdth_']]
swath <- app.n[['Swth_Wdth_']]
swath <- app.n[['Swth_Wdth_']]
units(swath) <- units::as_units('ft')
summary(swath)
units(swath) <- units::as_units('m')
summary(swath)
angle <- .pa_estimate_angle(st_geometry(app.n))
angle
head(angle)
cores = 5
cores <- 5
app.pols
app.n
app.pols <- pa_make_vehicle_polygons(sf::st_geometry(app.n),
swath,
distance,
angle,
cores = cores)
dim(angle)
length(angle)
length(swath)
length(distance)
distance <- app.n[['Distance_f']]
units(distance) <- units::as_units('ft')
units(distance) <- units::as_units('m')
length(distance)
app.pols <- pa_make_vehicle_polygons(sf::st_geometry(app.n),
swath,
distance,
angle,
cores = cores)
plot(app.pols)
plot(app.pols, col = 'transparent', border = 'black')
plot(st_buffer(app.pols[1]), 100)
plot(st_buffer(app.pols[1], 100))
plot(st_buffer(app.pols[1], 100), border = 'transparent')
plot(app.pols, add = TRUE)
cores <- 8
adj.app <- pa_adjust_obs_effective_area(harvest.pols,
crop.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = cores,
verbose)
adj.app <- pa_adjust_obs_effective_area(harvest.pols,
f.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = cores,
verbose)
adj.app <- pa_adjust_obs_effective_area(app.pols,
f.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = cores,
verbose)
adj.app <- pa_adjust_obs_effective_area(app.pols,
f.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = cores,
TRUE)
devtools::load_all()
adj.app <- pa_adjust_obs_effective_area(app.pols,
f.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = cores,
TRUE)
devtools::load_all()
adj.app <- pa_adjust_obs_effective_area(app.pols,
f.mass,
var.label = 'mass',
overlap.threshold = 0.5,
cores = 10,
TRUE)
adj.app
plot(adj.app)
plot(adj.app['adj.mass'])
plot(adj.app, border = 'transparent')
plot(adj.app['adj.mass'], border = 'transparent')
app.app <- pa_apport_mass(sf::st_geometry(adj.app),
adj.app$adj.mass)
adj.app$adj.mass
adj.app$adj.mass |> head()
sf::st_geometry(adj.app)
app.app <- pa_apport_mass(sf::st_geometry(adj.app),
adj.app$adj.mass)
head(adj.app)
st_geometry_type(adj.app)
st_geometry_type(adj.app) |> unique()
debugonce(pa_apport_mass)
app.app <- pa_apport_mass(sf::st_geometry(adj.app),
adj.app$adj.mass)
debugonce(pa_apport_mass)
debugonce(pa_apport_mass)
app.app <- pa_apport_mass(sf::st_geometry(adj.app),
adj.app$adj.mass)
dat
dat['mass']
app.grid
polygons
st_make_grid(polygons, cellsize = rep(cell.size, 2))
st_make_grid(st_as_sf(polygons), cellsize = rep(cell.size, 2))
## testing how to aggregate the nitrogen and seed information
app.n <- pa_2utm(app.n)
app.n
## testing how to aggregate the nitrogen and seed information
app.n <- pa_2utm(app.n)
## testing how to aggregate the nitrogen and seed information
app.n <- pa_2utm(app.n, verbose = TRUE)
flow <- app.n[['Rate__Mass']]
units(flow) <- units::as_units('lb/s')
moisture <- 0
units(moisture) <- units::as_units('%')
interval <- app.n[['Duration_s']]
units(interval) <- units::as_units('s')
f.mass <- pa_flow2mass(flow, interval, moisture)
swath <- app.n[['Swth_Wdth_']]
units(swath) <- units::as_units('ft')
units(swath) <- units::as_units('m')
distance <- app.n[['Distance_f']]
units(distance) <- units::as_units('ft')
units(distance) <- units::as_units('m')
angle <- .pa_estimate_angle(st_geometry(app.n))
app.pols <- pa_make_vehicle_polygons(sf::st_geometry(app.n),
swath,
distance,
angle,
cores = cores)
