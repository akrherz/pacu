run.test <-  get(".run.local.tests", envir = pacu.options)

if(run.test){

  require(pacu)
  require(terra)
  require(sf)
  require(gstat)
  require(units)
  require(nlraa)
  require(exactextractr)
  library(ggplot2)
  require(nlme)


  cores <- 20
  verbose <- TRUE

  ## Initial set up ----

  ## Choosing one of the DIFM fields so we can look into how to
  ## re use the harvest file....
  raw.yield <- st_read('./tests-data/wendte-2018/raw-yield.shp')
  boundary <- st_read('./tests-data/wendte-2018/boundary.shp')
  trial.design <- (st_read('./tests-data/wendte-2018/trial-design.shp'))

  trial.design <- pa_2utm(trial.design)


  ## There are some weird observations in terms of distance
  ## removing those for now
  raw.yield <- subset(raw.yield, Distance_f < 60)

  ## Converting to UTM
  raw.yield <- pa_2utm(raw.yield)
  boundary <- pa_2utm(boundary)

  ## Harvest polygons
  v.pols <-   pa_make_vehicle_polygons(sf::st_geometry(raw.yield),
                                       raw.yield$Swth_Wdth_ * 0.3048,
                                       raw.yield$Distance_f * 0.3048,
                                       cores = cores,
                                       verbose = verbose)

  adj.pols <- pa_adjust_obs_effective_area(v.pols,
                                           rep(1, length(v.pols)),
                                           var.label = 'mass',
                                           overlap.threshold = 0,
                                           cores = cores,
                                           verbose = verbose)

  adj.pols.backup <- adj.pols

  adj.pols <- subset(adj.pols, area.ratio > 0)



  ## Beginning simulations ----

  ### Simulation parameters
  nsim <- 20
  std.range <- c(0.01, seq(0.05, 0.3, 0.05))
  true.gsprocess <- vgm( 0.015, "Exp", 45)

  sim.parms <- expand.grid(iteration = 1:nsim,
                           std = std.range)

  ## Setting up the nitrogen rates
  ## there are 160 plots in the treatments
  ## there are some border plots that get a flat rate of 150
  nrates <- seq(0, 300, 20)
  nrates <- rep(nrates, 10)

  res <- list()
  metrics <- list()
  fail.counter <- list(true = 0, snk = 0, rk = 0)

  for (i in 1:nrow(sim.parms)) {

    cat('Iteration #', i, ' out of ', nrow(sim.parms), '\n', sep = '')

  ## Modifying the treatment structure to reflect a nitrogen trial
  trial.design$eu <- 1:nrow(trial.design)
  trial.design$nrate <- 100
  trial.design$nrate[trial.design$treat_type != 17] <- nrates[sample.int(length(nrates))]


  ## Creating a simulation in a 5m x 5m grid
  sim.grid <- st_make_grid(boundary, cellsize = c(10, 10))
  sim.grid <- st_as_sf(sim.grid)
  st_crs(sim.grid) <- st_crs(boundary)

  zeros <- which(trial.design$nrate == 0)

  ## Simulating a Gaussian process
  gsproc <- gstat(formula = z ~ 1,
                  dummy = TRUE,
                  beta = 0,
                  model = true.gsprocess,
                  nmax = 300)

  gpreds <- predict(gsproc, st_centroid(st_geometry(sim.grid)), nsim = 1, debug.level = -1)
  sim.grid$sim1 <- gpreds$sim1

  r.grid <- rast(extent = st_bbox(st_buffer(sim.grid, 40)),
                 resolution = c(1, 1),
                 crs = st_crs(trial.design)$wkt)

  r.gsp <- rasterize(sim.grid, r.grid, 'sim1')
  r.fert <- rasterize(trial.design, r.grid, 'nrate')
  r.yl <-   app(r.fert, function(x) linp(x, 7, 0.03, 150))

  names(r.yl) <- 'yield_gm2'
  r.resp <- (r.yl + ( global(r.yl, 'mean', na.rm = T)[1, ] * r.gsp)) * 100 ## response var is in g/m2 now
  r.resp[is.na(r.resp)] <- 0
  names(r.resp) <- 'yield_gm2'

  hv.vals <- exact_extract(r.resp,
                           adj.pols,
                           function(values, coverage_fraction)
                                    weighted.mean(values, coverage_fraction, na.rm=TRUE))



  hv.pols <- adj.pols
  hv.pols$yield_g <- hv.vals
  hv.pols$yield_gm2 <- hv.pols$yield_g

  ## At this point, the "resp" variable indicates de mass of grain
  ## per unit of area
  hv.pols$mass <- hv.pols$yield_gm2 * hv.pols$area.chopped

  ## Now, we are ready to run this synthetic data trough the
  ## yield map algorithm and see if we can recover the trend
  ## for now, I am adding a random error... this error could be
  ## a function of the moisture in the future...
  hv.pols$mass <- hv.pols$mass # +  mean(hv.pols$mass) * rnorm(nrow(hv.pols), 0, sim.parms$std[i])

  ## Adding the data to a toy data set so we can go through the different
  ## yield map algorithms
  toy.data <- raw.yield
  toy.data$id <- 1:nrow(toy.data)

  hv.data <- as.data.frame(hv.pols)
  hv.data$yld_kgha <- 10  * hv.data$mass / hv.data$area.initial
  toy.data <- merge(toy.data, hv.data[c('id', 'mass', 'yld_kgha')], by = 'id', all.x = TRUE)
  toy.data$mass[is.na(toy.data$mass)] <- 0
  toy.data$yld_kgha[is.na(toy.data$yld_kgha)] <- 0
  toy.data$Crop_Flw_M <- toy.data$mass/ (453.59 * toy.data$Duration_s)
  toy.data$Moisture__ <- 0


  ## Yield maps ----
  ### Simple algorithm and not kriging
  yld.simple.nk <- pa_yield(input = toy.data,
                             trial.design = trial.design,
                             data.columns = c('yld_kgha', 'Moisture__'),
                             data.units = c('kg/ha', '%'),
                             algorithm = 'simple',
                             clean = FALSE,
                             var.label = 'yield.simple.nk',
                             smooth.method = 'none')

  ### Ritas and kriging
  yld.ritas.k <-  pa_yield(input = toy.data,
                             trial.design = trial.design,
                             algorithm = 'ritas',
                             clean = FALSE,
                             cores = cores,
                             var.label = 'yield.ritas.k',
                             smooth.method = 'krige',
                             nmax = 300)


  tyield.vals <- exactextractr::exact_extract(x = r.resp,
                                              y = trial.design,
                                              weights = 'area',
                                              fun = "weighted_mean")

  true.yield <- st_geometry(trial.design)
  true.yield <- st_as_sf(true.yield)
  true.yield$yield_tha <-  tyield.vals / 100 ## convert to t/ha


  ## Combining all yield maps formed
  cmp <- st_join(yld.simple.nk$yield, trial.design[c('nrate', 'treat_type')], left = TRUE, join = st_equals)
  cmp <- st_join(cmp, yld.ritas.k$yield, left = TRUE, join = st_equals)
  cmp <- st_join(cmp, true.yield['yield_tha'], left = TRUE, join = st_equals)
  cmp <- subset(cmp, treat_type != 17)


  with(cmp, {
    par(mfrow = c(1,2))
    plot(nrate, yield_tha, ylim = c(5, 15), pch = 16, ylab = 'Yield (t/ha)', xlab = c('N rate (kg/ha)'))
    points(nrate, yield.simple.nk, col = 'red')
    points(nrate, yield.ritas.k, col = 'blue')
    legend('bottomright', pch = c(16, 1, 1), col = c('black', 'red', 'blue'),
           legend = c('TRUE', 'S', 'R'))

    plot(x = yield_tha, y = yield.ritas.k, xlim = c(5, 14), ylim = c(5, 14), col = 'blue')
    abline(0, 1, col = 'red')
  })


   ## Metrics ----
  alg.metrics <- data.frame(iteration = i, std = sim.parms$std[i],
                            bias.snk = with(cmp, sum(yield.simple.nk - yield_tha) / length(yield_tha)), # nolint: line_length_linter.
                            bias.rk = with(cmp, sum(yield.ritas.k - yield_tha) / length(yield_tha)),
                            rmse.snk = with(cmp, sqrt(sum((yield.simple.nk - yield_tha)**2) / length(yield_tha))),
                            rmse.rk = with(cmp, sqrt(sum((yield.ritas.k - yield_tha)**2) / length(yield_tha))))

  metrics <- append(metrics, list(alg.metrics))


  ## Fitting models ----
  cmp$eu <- 1:nrow(cmp)
  cmpg <- st_centroid(cmp)
  cmpg <- cbind(cmpg, st_coordinates(cmpg))

  ## Simple algorithm model
  fit1.1 <- try(gnls(yield.simple.nk ~ SSlinp(nrate, a, b, xs),
                     correlation = corExp(form = ~ X + Y ),
                     start = c(a = 7, b = 0.03, xs = 150),
                     data = cmpg), silent = TRUE)

  if(inherits(fit1.1, 'try-error')){
    fail.counter[['snk']] <- fail.counter[['snk']] + 1
    }


  ## Ritas kriged
  fit2.1 <- try(gnls(yield.ritas.k ~ SSlinp(nrate, a, b, xs),
                 correlation = corExp(form = ~ X + Y),
                 start = c(a = 7, b = 0.03, xs = 150),
                 data = cmpg), silent = TRUE)


  if(inherits(fit2.1, 'try-error')){
    fail.counter[['rk']] <- fail.counter[['rk']] + 1
    }

  ## TRUE
  fit3.1 <- try(gnls(yield_tha ~ SSlinp(nrate, a, b, xs),
                 correlation = corExp(form = ~ X + Y ),
                 start = c(a = 7, b = 0.03, xs = 150),
                 data = cmpg), silent = TRUE)


  if(inherits(fit3.1, 'try-error')){
    fail.counter[['true']] <- fail.counter[['true']] + 1
  }


 if(any(sapply(list(fit1.1, fit2.1, fit3.1), function(x) inherits(x, 'try-error')))){
   next
 }


  parms1 <- data.frame(intervals(fit1.1)$coef)
  parms1$parm <- row.names(parms1)
  parms1$alg <- 'SNK'


  parms2 <- data.frame(intervals(fit2.1)$coef)
  parms2$parm <- row.names(parms2)
  parms2$alg <- 'RK'

  parms3 <- data.frame(intervals(fit3.1)$coef)
  parms3$parm <- row.names(parms3)
  parms3$alg <- 'True'


  ans <- do.call(rbind, list(parms1, parms2,  parms3))
  ans$iteration <- i
  ans$std <- sim.parms$std[i]

  res <- append(res, list(ans))
}
res <- do.call(rbind, res)
metrics <- do.call(rbind, metrics)

saveRDS(res, './tests-results/simulations/simulation-res.rds')
saveRDS(metrics, './tests-results/simulations/simulation-metrics.rds')
saveRDS(fail.counter, './tests-results/simulations/fail-counter.rds')

ggplot(res) +
  geom_boxplot(aes(x = `est.`, y = as.factor(std),col = alg))+
  facet_wrap(~parm, scales = 'free')+
  labs(x = 'Parameter value', y = 'Standard Deviation', fill = '',
       caption = 'RK: Ritas Krigged\nSNK: Simple not Krigged')

ggplot(metrics) +
  geom_point(aes(x = std, y = rmse.snk, col = 'SNK'))+
  geom_point(aes(x = std, y = rmse.rk, col = 'RK'))+
  labs(x = 'Standard deviation', y = 'RMSE (t/ha)', fill = '',
       caption = 'RK: Ritas Krigged\nSNK: Simple not Krigged')

ggplot(metrics)+
  geom_point(aes(x = std, y = bias.snk, col = 'SNK'))+
  geom_point(aes(x = std, y = bias.rk, col = 'RK'))+
  labs(x = 'Standard deviation', y = 'Bias (t/ha)', fill = '',
       caption = 'RK: Ritas Krigged\nSNK: Simple not Krigged')

}

