#'
#' @title Adjust the effective area of each observation based on vehicular polygon overlap
#' @description Adjust the effective area of each observation based on vehicular polygon overlap
#' @name pa_adjust_obs_effective_area
#' @rdname pa_adjust_obs_effective_area
#' @param polygons vehicular polygons of the observation
#' @param obs.vector a vector containing the observations
#' @param var.label a string used to label the columns (e.g., yield)
#' @param overlap.threshold a fraction threshold to remove observations.
#' @param cores the number of cores used in the operation
#' @param verbose whether to print operation details
#' @details This function will make use of the vehicular polygons to evaluate the overlap between
#' polygons and adjust the variable in obs.vector to the effective area in the polygon. This is primarely
#' intended for yield.
#' @return returns an sf object
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'

pa_adjust_obs_effective_area <- function(polygons,
                                         obs.vector,
                                         var.label = 'yield',
                                         overlap.threshold = 0,
                                         cores = 1L,
                                         verbose = FALSE) {

  obs.df <- data.frame(obs = obs.vector,
                       id = 1:length(obs.vector))
  names(obs.df) <- c(paste0('obs.', var.label), 'id')
  chp.polygons <- .pa_solve_vehicle_overlap(polygons, cores = cores, verbose = verbose)
  chp.polygons <- st_as_sf(chp.polygons)
  chp.polygons$id <- 1:nrow(chp.polygons)
  chp.polygons <- as.data.frame(chp.polygons)
  chp.polygons <- merge(chp.polygons, obs.df, by = 'id')
  polygons <- st_as_sf(polygons)
  polygons$id <- 1:nrow(polygons)
  polygons$area.initial <- as.numeric(st_area(polygons))
  polygons <- as.data.frame(polygons)
  chp.polygons <- merge(chp.polygons, polygons[c('id', 'area.initial')], by = 'id')
  chp.polygons <- st_as_sf(chp.polygons)
  chp.polygons$area.chopped <- as.numeric(st_area(chp.polygons))
  chp.polygons$area.ratio <- chp.polygons$area.chopped / chp.polygons$area.initial
  a.ratios <- data.frame(adj.obs = chp.polygons[[paste0('obs.', var.label)]] / chp.polygons$area.chopped)
  names(a.ratios) <- paste0('adj.', var.label)
  chp.polygons <- cbind(chp.polygons, a.ratios)
  chp.polygons <- subset(chp.polygons, area.ratio >= overlap.threshold)

  return(chp.polygons)
}



#'
#' @title Make vehicular polygons for yield monitor observations
#' @description Make vehicular polygons for yield monitor observations
#' @name pa_make_vehicle_polygons
#' @rdname pa_make_vehicle_polygons
#' @param points a vector of points
#' @param swath a vector containing the swath of the vehicle
#' @param distance a vector containing the distance traveled by the vehicle
#' @param angle a vector containing the angle of the vehicle's trajectory. If not supplied, the function will attempt to estimate the
#' trajectory angle using the geographical information contained in the georeferenced points/
#' @param cores the number of cores used in the operation
#' @param verbose whether to print operation details
#' @details This function will create vehicular polygons based on the distance between points,
#' angle of the vehicle's trajectory, and swath.
#' @return returns an sf object
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'
#'
pa_make_vehicle_polygons <- function(points, swath, distance, angle = NULL, cores = 1L, verbose = FALSE){

  if(!inherits(points, c("sf", "sfc", "sfg")))
    stop("Object 'points' should be of class 'sf', 'sfc' or 'sfg'", call. = FALSE)

  crt.crs <- sf::st_crs(points)
  is.utm <- grepl('UTM zone', crt.crs$wkt)
  if(!is.utm){
    stop("points should be in UTM")
  }

  if(is.null(angle)) {angle <- .pa_estimate_angle(points)}

  attributes(angle) <- NULL

  arg.lens <- sapply(list(points, swath, distance, angle), length)
  if(length(unique(arg.lens)) > 1)
    stop('all arguments should be of the same length', call. = FALSE)

  if(verbose)
    cat('Building', length(swath), 'polygons in', cores, 'cores.\n')
  if(cores != 1L){
    cores.avlb <- parallel::detectCores(logical = TRUE)
    ncores <- ifelse(cores > cores.avlb, cores.avlb, cores)
    cl <- parallel::makeCluster(ncores)
    parallel::clusterExport(cl, c('.pa_make_vehicle_polygon', 'points', 'swath', 'distance', 'angle'), environment())
    parallel::clusterEvalQ(cl, {library('sf')})
    pols <- parallel::parLapply(cl,
                                1:length(swath),
                                function(i) {
                                  .pa_make_vehicle_polygon(points[i],
                                                           swath[i],
                                                           distance[i],
                                                           angle[i])
                                })

    parallel::stopCluster(cl)
  }else{
    pols <- lapply(1:length(swath), function(i) {
      .pa_make_vehicle_polygon(points[i],
                               swath[i],
                               distance[i],
                               angle[i])})


  }
  pols <- do.call(c, pols)
  return(pols)
}






#'
#' @title Impose a regular grid over yield polygons
#' @description Impose a regular grid over yield polygons
#' @name pa_apport_mass
#' @rdname pa_apport_mass
#' @param polygons sf object containing polygon geometries
#' @param mass.vector a vector of mass observations
#' @param boundary optional sf object representing the field's outer boundary. If it not supplied, the function attemps to generate
#' a boundary from the observed points.
#' @param sum whether the apported values should be summed. If FALSE, the average is calculated.
#' @param cell.size optional numerical value (length 1) to be used as the width and height of the grid
#' @details This function will impose a regular grid over the yield polygons and compute the weighted average
#' of the mass value represented by each polygon. The averages are weighted according to the polygon area.
#' @return returns an sf object
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'
#'
pa_apport_mass <- function(polygons,
                           mass.vector,
                           boundary = NULL,
                           cell.size = NULL,
                           sum = FALSE,
                           scale.cellsize = 1,
                           cores = 1L){
  if(is.null(cell.size)){
    cell.size <-  scale.cellsize * sqrt(median(sf::st_area(polygons)))
    cell.size <- as.numeric(cell.size)
  }
  if(is.null(boundary)){
    boundary <- sf::st_boundary(polygons)
  }

  dat <- sf::st_as_sf(polygons)
  dat$mass <- mass.vector
  app.grid <- sf::st_make_grid(boundary, cellsize = rep(cell.size, 2))
  app.grid <- sf::st_intersection(app.grid, boundary)
  #apported <- suppressWarnings(sf::st_interpolate_aw(dat['mass'], app.grid, extensive = sum))
  apported <- .pa_areal_weighted_average(dat, app.grid, 'mass', sf::st_intersects, cores)
  return(apported)
}


#'
#' @title Convert crop flow to mass
#' @description Convert crop flow to mass
#' @name pa_flow2mass
#' @rdname pa_flow2mass
#' @param crop.flow a vector of crop flow in lb/s
#' @param interval a vector the interval between measurements in seconds
#' @param moisture vector of the recorded grain moisture in \%
#' @details This function will convert crop flow in lb/s to dry mass in g
#' @return returns a vector containing mass (g)
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'
pa_flow2mass <- function(crop.flow, interval, moisture){
  ## crop.flow must be in g/s
  ## interval in seconds
  ## moisture in %

  mass <- crop.flow * interval
  attributes(mass) <- NULL
  attributes(moisture) <- NULL
  mass <- .pa_moisture(mass, moisture, 0)
  mass
}


#'
#' @title Reproject a sf object to UTM coordinates
#' @description Reproject a sf object to UTM coordinates
#' @name pa_2utm
#' @rdname pa_2utm
#' @param df sf object to be reprojected to UTM coordinates
#' @param verbose whether to print operation details
#' @details This function will attempt to automatically determine the adequate UTM zone and reproject
#' a sf object,
#' @return returns a sf object
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'
#'
pa_2utm <- function(df, verbose = FALSE) {

  crt.crs <- sf::st_crs(df)
  is.utm <- grepl('UTM zone', crt.crs$wkt)

  if(is.utm){
    if(verbose) cat("Current CRS is already UTM\n")
    return(df)
  }
  ac <- st_coordinates(st_centroid(st_as_sfc(st_bbox(df))))
  epsg.code <- .pa_coord2utm(lat = ac[2], long = ac[1])
  if(verbose) cat('Transforming CRS to EPSG:', epsg.code, '\n', sep = '')
  df <- st_transform(df, epsg.code)
  df
}


#'
#' @title Adjust for the time lag between the crop being cut by the combine and the sensor recording a data point
#' @description Adjust for the time lag between the crop being cut by the combine and the sensor recording a data point
#' @name pa_adjust_lag
#' @rdname pa_adjust_lag
#' @param input an sf object containing the input data from a yield monitor
#' @param time.adj time (s) to used to adjust the observations
#' @param time.col time columns in the input
#' @details This function will adjust for the time lag between the crop being cut by the combine and the sensor recording
#' a data point.
#' @return returns a sf object
#' @author Caio dos Santos and Fernando Miguez
#' @export
#' @examples
#' \donttest{
#' ## for examples, see vignette pacu
#' }
#'
#'
pa_adjust_lag <- function(input, time.adj, time.col) {
  if (time.adj > 0){

    input$time <- cumsum(input[[time.col]])
    pts <- st_geometry(input)
    idf <- as.data.frame(input)
    idf <- idf[-grep('geometry', names(idf))]
    idf <- subset(idf, time > time.adj)
    obs.shift <- dim(input)[1] - dim(idf)[1]
    shifted <- pts[1:(length(pts) - obs.shift) ]
    shifted <- cbind(idf, shifted)
    shifted <- st_as_sf(shifted)
    return(shifted)

  }else {

    return(input)
  }

}

