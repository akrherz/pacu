data.columns = c(treatment = 'Prod_ac_h_'),
grid = rx,
algorithm = 'ritas',
unit.system = 'metric',
var.label = 'nitrogen',
na.to.zero = TRUE,
cores = 10
)
## with the trial design and using the nitrogen rate as a predictor
pyld.rx.n <- pa_yield(yld,
grid = app.n,
algorithm = "ritas",
unit.system = "standard",
overlap.threshold = 0.1,
clean = TRUE,
formula = z ~ nrate + I(nrate ^ 2),
cores = 8,
remove.crossed.polygons = TRUE,
smooth.method = "krige",
lbs.per.bushel = 56,
moisture.adj = 15.5,
verbose = 2,
maxdist = 200)
pyld.rx.n2 <- pa_yield(yld,
grid = nit2,
algorithm = "ritas",
unit.system = "standard",
overlap.threshold = 0.1,
clean = TRUE,
formula = z ~ nitrogen + I(nitrogen ^ 2),
cores = 8,
remove.crossed.polygons = TRUE,
smooth.method = "krige",
lbs.per.bushel = 56,
moisture.adj = 15.5,
verbose = 2,
maxdist = 200)
pyld.rx.n2
pa_plot(pyld.rx.n2)
summary(pyld.rx.n2, by = 'nrate')
summary(pyld.rx.n2, by = 'nitrogen')
## Fitting the models
dat <- pyld.rx.n2$yield
dat <- cbind(dat, st_coordinates(st_centroid(dat)))
dat <-  as.data.frame(dat)
dat <- dat[-1:-2, ]
fit4 <- gls(yield ~ nrate,
method = 'ML',
data = dat)
fit4 <- gls(yield ~ nitrogen,
method = 'ML',
data = dat)
fit5 <- gls(yield ~ nitrogen,
method = 'ML',
correlation = corSpher(form = ~ X + Y),
data = dat)
IC_tab(fit4, fit5)
## The variogram looks good as well
pa_plot(pyld.rx.n2, plot.type = 'variogram')
library(tmap)
library(ggplot2)
plot(rx['TgtN'], pal = function(n) hcl.colors(n, 'Temps', rev = TRUE))
pa_plot(pyld.rx.n, frame = FALSE, interactive = TRUE)
preds.s <- dat
preds.s <- cbind(preds.s, predict_gls(fit2,
interval = 'conf',
plevel = 2))
plot(dat$nitrogen, dat$yield)
fit5
anova(fit5)
trial.design
## this pa_trial function is still experimental
devtools::load_all()
nit2 <- pa_trial(input = trial.design,
data.columns = c(treatment = 'Prod_ac_h_'),
grid = rx,
algorithm = 'ritas',
unit.system = 'metric',
var.label = 'nitrogen',
na.to.zero = TRUE,
cores = 10
)
plot(nit2)
nit2
tt <- st_join(nit2, rx, left = T, join = st_equals)
tt <- st_join(nit2, st_transform(rx, st_crs(nit2)), left = T, join = st_equals)
tt
plot(tt)
plot(tt$nitrogen, tt$TgtN)
head(trial.design)
nit2 <- pa_trial(input = trial.design,
data.columns = c(treatment = 'Rt_Apd_Liq'),
grid = rx,
algorithm = 'ritas',
unit.system = 'metric',
var.label = 'nitrogen',
na.to.zero = TRUE,
cores = 10
)
tt <- st_join(nit2, st_transform(rx, st_crs(nit2)), left = T, join = st_equals)
plot(tt$nitrogen, tt$TgtN)
plot(tt$nitrogen, tt$TgtN)
head(trial.design)
yld$mass <- with(yld, 1000 * WetMass * (SWATHWIDTH * DISTANCE) / (43550 * 2.471577) )
pyld.simple <- pa_yield(input = yld,
algorithm = 'simple',
unit.system = 'standard',
lbs.per.bushel = 56,
moisture.adj = 15.5)
pa_plot(pyld.simple)
summary(pyld.simple)
## with the trial design and using the nitrogen rate as a predictor
pyld.rx.n <- pa_yield(yld,
grid = rx,
algorithm = "ritas",
unit.system = "standard",
overlap.threshold = 0.1,
clean = TRUE,
formula = z ~ TgtN + I(TgtN ^ 2),
cores = 8,
remove.crossed.polygons = TRUE,
smooth.method = "krige",
lbs.per.bushel = 56,
moisture.adj = 15.5,
verbose = 2,
maxdist = 200)
## with the as applied nitrogen data and using nitrogen as a predictor
pyld.rx.n2 <- pa_yield(yld,
grid = nit2,
algorithm = "ritas",
unit.system = "standard",
overlap.threshold = 0.1,
clean = TRUE,
formula = z ~ nitrogen + I(nitrogen ^ 2),
cores = 8,
remove.crossed.polygons = TRUE,
smooth.method = "krige",
lbs.per.bushel = 56,
moisture.adj = 15.5,
verbose = 2,
maxdist = 200)
## It seems like everything worked :D
pa_plot(pyld.rx.n)
## Fitting the models
dat <- pyld.rx.n2$yield
## Fitting the models
dat <- pyld.rx.n2$yield
dat <- cbind(dat, st_coordinates(st_centroid(dat)))
dat <-  as.data.frame(dat)
dat <- dat[-1:-2, ]
fit4 <- gls(yield ~ nitrogen,
method = 'ML',
data = dat)
fit5 <- gls(yield ~ nitrogen,
method = 'ML',
correlation = corSpher(form = ~ X + Y),
data = dat)
IC_tab(fit4, fit5)
plot(dat$nitrogen, dat$yield)
fit5
R2M(fit5)
R2M(fit4)
## Fitting the models
dat <- pyld.rx.n$yield
dat <- cbind(dat, st_coordinates(st_centroid(dat)))
dat <-  as.data.frame(dat)
dat <- dat[-1:-2, ]
fit5 <- gls(yield ~ TgtN,
method = 'ML',
correlation = corSpher(form = ~ X + Y),
data = dat)
fit5
fit5
fit5 |> anova()
R2M(fit5)
## Fitting the models
dat <- pyld.rx.n2$yield
dat <- cbind(dat, st_coordinates(st_centroid(dat)))
dat <-  as.data.frame(dat)
dat <- dat[-1:-2, ]
fit4 <- gls(yield ~ nitrogen,
method = 'ML',
data = dat)
fit5 <- gls(yield ~ nitrogen,
method = 'ML',
correlation = corSpher(form = ~ X + Y),
data = dat)
IC_tab(fit4, fit5)
anova(fit5)
fit5
.pa_time2interval('03:53:04 PM')
as.Date('03:53:04 PM')
as.POSIXlt('03:53:04 PM')
as.POSIXlt('03:53:04 PM', '%I:%M:OSZ%p')
as.POSIXlt('03:53:04 PM', '%I:%M:%S')
as.POSIXlt('03:53:04 PM', '%I:%M:%S %p')
as.POSIXlt('03:53:04 PM', format = '%I:%M:%S %p')
.pa_time2interval('03:53:04 PM')
devtools::load_all()
.pa_time2interval('03:53:04 PM')
.pa_time2interval(rep('03:53:04 PM', 2)
)
.pa_time2interval(rep('03:53:04 PM', 3))
devtools::build()
devtools::install()
devtools::load_all()
devtools::build()
devtools::install()
devtools::build()
devtools::install()
devtoo
devtools::check()
devtools::load_all()
library(sf)
rd <- st_read('../phd/peter-yield-monitor/raw-data/Nitrogen_Trials_2001_Iowa/JF2001.shp')
pa_check_yield(rd)
devtools::load_all()
rd <- st_read('../phd/peter-yield-monitor/raw-data/Nitrogen_Trials_2001_Iowa/JF2001.shp')
pa_check_yield(rd)
debugonce(pa_check_yield)
pa_check_yield(rd)
i
ans
ans
devtools::load_all()
rd <- st_read('../phd/peter-yield-monitor/raw-data/Nitrogen_Trials_2001_Iowa/JF2001.shp')
pa_check_yield(rd)
debugonce(pa_check_yield)
pa_check_yield(rd)
devtools::load_all()
pa_check_yield(rd)
devtools::load_all()
rd <- st_read('../phd/peter-yield-monitor/raw-data/Nitrogen_Trials_2001_Iowa/JF2001.shp')
pa_check_yield(rd)
devtools::load_all()
pa_check_yield(rd)
pa_check_yield(rd, 'ritas')
devtools::build()
devtools::install()
library(sf)
library(pacu)
library(nlme)
library(nlraa)
## reading and example in
rd <- st_read('./tests-data/kyveryga-2001/JF2001.shp')
## adding the crs information
rd <- st_transform(rd, 32615)
## first look at the yield data
pa_check_yield(rd)
## Since I do not have the treatment polygons, I will build
## them from the data that peter gave us
trts <- by(rd, rd$STRIP, function(strip) {
pts <- st_buffer(strip, c(0.5,4.5/2), endCapStyle = 'SQUARE')
around <- st_convex_hull(st_union(pts))
pr <- st_as_sf(around)
pr$STRIP <- strip$STRIP[1]
pr$RATE <- strip$RATE[1]
pr
})
trts <- do.call(rbind, trts)
trts <- st_difference(trts)
plot(trts)
## inputing interval and swath
## the interval and swath were retrieved from the
## publication that peter sent
rd$interval <- 1
rd$swath <- 4.57
## checking the yield data once more
pa_check_yield(rd)
## The algorithm is having a hard time guessing the units here
yld1 <- pa_yield(input = rd,
data.units = c('kg/ha'),
algorithm = 'simple',
unit.system = 'metric')
pa_plot(yld1,
legend.outside = TRUE)
## ritas using the trial design grid
yld2 <- pa_yield(input = rd,
grid = trts,
formula = z ~ RATE,
algorithm = 'ritas',
moisture.adj = 15.5,
cores = 8,
smooth.method = 'krige',
unit.system = 'metric',
verbose = 2)
pa_plot(yld2, legend.outside = TRUE)
plot(yld2$yield$RATE, yld2$yield$yield,
xlab = 'Nitrogen Rate', ylab = 'Yield (t/ha)')
summary(yld2, by = 'RATE')
## fitting models to the data
pd <- yld2$yield
pd$rate <- pd$RATE
pd <- cbind(pd, st_coordinates(st_centroid(pd)))
pd <- as.data.frame(pd)
fm1.1 <- gnls(yield ~ SSlinp(rate, a, b, xs),
data = pd)
fm1.2 <- update(fm1.1,
correlation = corExp(form =  ~ X + Y))
fm1.3 <- gnls(yield ~ SSquadp(rate, a, b, c, xs),
data = pd)
IC_tab(fm1.1, fm1.2, fm1.3)
## visualizing the fitted model
preds <- data.frame(rate = 0:180)
preds <- cbind(preds, predict_gnls(fm1.1, interval = 'conf', newdata = preds))
plot(1, type = 'n',  xlab = 'Nitrogen rate (kg/ha)', ylab = 'Yield (t/ha)',
xlim = c(0, 200), ylim = c(5, 11))
bp <- intervals(fm1.1)$coef[3, ]
for (x in seq(bp[1], bp[3], 0.1)){
abline(v = x, col = 'lightpink')
}
polygon(x = c(preds$rate, rev(preds$rate)),
y = c(preds$Q2.5, rev(preds$Q97.5)),
col = 'lightgrey', border = 'transparent')
points(pd$rate, pd$yield, pch = 16)
lines(preds$rate, preds$Estimate)
abline(v = coef(fm1.1)['xs'], col = 'red', lty = 2)
## This code is intented to explore the data provided by
## Peter aftet a meeting about how to process yiled data
library(sf)
library(pacu)
library(nlme)
library(nlraa)
## reading and example iin
rd <- st_read('./tests-data/kyveryga-2001/JF2001.shp')
## adding the crs information
rd <- st_transform(rd, 32615)
## first look at the yield data
pa_check_yield(rd)
## Since I do not have the treatment polygons, I will build
## them from the data that peter gave us
trts <- by(rd, rd$STRIP, function(strip) {
pts <- st_buffer(strip, c(0.5,4.5/2), endCapStyle = 'SQUARE')
around <- st_convex_hull(st_union(pts))
pr <- st_as_sf(around)
pr$STRIP <- strip$STRIP[1]
pr$RATE <- strip$RATE[1]
pr
})
trts <- do.call(rbind, trts)
trts <- st_difference(trts)
plot(trts)
## inputing interval and swath
## the interval and swath were retrieved from the
## publication that peter sent
rd$interval <- 1
rd$swath <- 4.57
## checking the yield data once more
pa_check_yield(rd)
## The algorithm is having a hard time guessing the units here
yld1 <- pa_yield(input = rd,
data.units = c('kg/ha'),
algorithm = 'simple',
unit.system = 'metric')
pa_plot(yld1,
legend.outside = TRUE)
## ritas using the trial design grid
yld2 <- pa_yield(input = rd,
grid = trts,
formula = z ~ RATE,
algorithm = 'ritas',
moisture.adj = 15.5,
cores = 8,
smooth.method = 'krige',
unit.system = 'metric',
verbose = 2)
pa_plot(yld2, legend.outside = TRUE)
plot(yld2$yield$RATE, yld2$yield$yield,
xlab = 'Nitrogen Rate', ylab = 'Yield (t/ha)')
summary(yld2, by = 'RATE')
## fitting models to the data
pd <- yld2$yield
pd$rate <- pd$RATE
pd <- cbind(pd, st_coordinates(st_centroid(pd)))
pd <- as.data.frame(pd)
fm1.1 <- gnls(yield ~ SSlinp(rate, a, b, xs),
data = pd)
fm1.2 <- update(fm1.1,
correlation = corExp(form =  ~ X + Y))
fm1.3 <- gnls(yield ~ SSquadp(rate, a, b, c, xs),
data = pd)
## it seems like the first model does a good enough job
## we could weigh the linp and quadp models based on AIC
## but for simplicity I will just continue with the first model
IC_tab(fm1.1, fm1.2, fm1.3)
## visualizing the fitted model
preds <- data.frame(rate = 0:180)
preds <- cbind(preds, predict_gnls(fm1.1, interval = 'conf', newdata = preds))
plot(1, type = 'n',  xlab = 'Nitrogen rate (kg/ha)', ylab = 'Yield (t/ha)',
xlim = c(0, 200), ylim = c(5, 11))
bp <- intervals(fm1.1)$coef[3, ]
for (x in seq(bp[1], bp[3], 0.1)){
abline(v = x, col = 'lightpink')
}
polygon(x = c(preds$rate, rev(preds$rate)),
y = c(preds$Q2.5, rev(preds$Q97.5)),
col = 'lightgrey', border = 'transparent')
points(pd$rate, pd$yield, pch = 16)
lines(preds$rate, preds$Estimate)
abline(v = coef(fm1.1)['xs'], col = 'red', lty = 2)
pa_plot(yld1,
legend.outside = TRUE)
pa_plot(yld2, legend.outside = TRUE)
plot(1, type = 'n',  xlab = 'Nitrogen rate (kg/ha)', ylab = 'Yield (t/ha)',
xlim = c(0, 200), ylim = c(5, 11))
bp <- intervals(fm1.1)$coef[3, ]
for (x in seq(bp[1], bp[3], 0.1)){
abline(v = x, col = 'lightpink')
}
polygon(x = c(preds$rate, rev(preds$rate)),
y = c(preds$Q2.5, rev(preds$Q97.5)),
col = 'lightgrey', border = 'transparent')
points(pd$rate, pd$yield, pch = 16)
lines(preds$rate, preds$Estimate)
abline(v = coef(fm1.1)['xs'], col = 'red', lty = 2)
fm1.1 <- gnls(yield ~ SSlinp(rate, a, b, xs),
data = pd)
fm1.2 <- update(fm1.1,
correlation = corExp(form =  ~ X + Y))
fm1.3 <- gnls(yield ~ SSquadp(rate, a, b, c, xs),
data = pd)
## it seems like the first model does a good enough job
## we could weigh the linp and quadp models based on AIC
## but for simplicity I will just continue with the first model
IC_tab(fm1.1, fm1.2, fm1.3)
plot(1, type = 'n',  xlab = 'Nitrogen rate (kg/ha)', ylab = 'Yield (t/ha)',
xlim = c(0, 200), ylim = c(5, 11))
bp <- intervals(fm1.1)$coef[3, ]
for (x in seq(bp[1], bp[3], 0.1)){
abline(v = x, col = 'lightpink')
}
polygon(x = c(preds$rate, rev(preds$rate)),
y = c(preds$Q2.5, rev(preds$Q97.5)),
col = 'lightgrey', border = 'transparent')
points(pd$rate, pd$yield, pch = 16)
lines(preds$rate, preds$Estimate)
abline(v = coef(fm1.1)['xs'], col = 'red', lty = 2)
library(apsimx)
library(apsimx)
lonlat <- c(-93.620369, 42.034534)
pwr <- get_power_apsim_met(lonlat, c('1990-01-01', '2023-12-31'))
class(pwr) <- 'data.frame'
pwr
head(pwr)
aggregate(pwr['radn'],
pwr['year'],
sum)
pwr <- get_power_apsim_met(lonlat, c('1990-01-01', '2023-12-31'))
pwr
aggregate(pwr['radn'],
pwr['year'],
sum)
aggregate(pwr['radn'],
pwr['year'],
sum) |> boxplot()
met <- pwr
class(met) <- 'data.frame'
aggregate(met['radn'],
met['year'],
sum)
subset(met, month > 5 & month < 11)
strftime(as.Date('2024-05-15'), '%j')
strftime(as.Date('2024-11-01'), '%j')
met <- subset(met, day > 136 & day < 306)
aggregate(met['radn'],
met['year'],
sum)
met <- subset(met, day > 136 & day < 280)
aggregate(met['radn'],
met['year'],
sum)
strftime(as.Date('2024-06-01'), '%j')
met <- subset(met, day > 153 & day < 280)
aggregate(met['radn'],
met['year'],
sum)
radnc <- aggregate(met['radn'],
met['year'],
sum)
boxplot(radnc$radn)
boxplot(radnc$radn, y = 'Yearly solar radiation (MJ/m2)')
boxplot(radnc$radn, ylab = 'Yearly solar radiation (MJ/m2)')
boxplot(radnc$radn, ylab = 'Yearly incident solar radiation (MJ/m2)')
strftime(as.Date('2024-11-01'), '%j')
strftime(as.Date('2024-10-01'), '%j')
met <- pwr
class(met) <- 'data.frame'
met <- subset(met, day > 140 & day < 280)
radnc <- aggregate(met['radn'],
met['year'],
sum)
boxplot(radnc$radn, ylab = 'Yearly incident solar radiation (MJ/m2)')
met <- subset(met, day > 153 & day < 280)
radnc <- aggregate(met['radn'],
met['year'],
sum)
boxplot(radnc$radn, ylab = 'Yearly incident solar radiation (MJ/m2)')
met <- pwr
class(met) <- 'data.frame'
met <- subset(met, day > 126 & day < 296)
radnc <- aggregate(met['radn'],
met['year'],
sum)
boxplot(radnc$radn, ylab = 'Yearly incident solar radiation (MJ/m2)')
met <- subset(met, day > 141 & day < 296)
radnc <- aggregate(met['radn'],
met['year'],
sum)
boxplot(radnc$radn, ylab = 'Yearly incident solar radiation (MJ/m2)')
mean(radnc$radn)
devtools::build()
devtools::install()
